/*
	빼는 횟수를 최대한 줄이는게 관건이다.
	수를 3으로 나눴을 때 나머지가 1이면 1을 빼주고 3으로 나누고,
	수를 3으로 나눴을 때 나머지가 2이면 2로 나누어 떨어지는 지 확인하고 안 나누어떨어지면 1 빼고 2로 나눠준다.
	근데 2번 빼는 범위 안에 3의 제곱수가 있으면 이게 또 두번 뺴는게 더 빠르다.
*/

/*
	위의 내용이 내가 생각한 첫번째 내용인데 틀렸다.
	그래서 서칭을 해보니 약간 브루트 포스처럼 느껴지는 다이나믹 프로그래밍이 있었다.
	그래서 이를 사용하여 코드를 짜보겠다.
	
	로직은 간단하다.
	주어진 수에서 1로 내려오는게 아니고 1부터 시작해서 주어진 수까지 전부 케이스 수를 조사하여 각각의 수까지 도달하는데 걸리는 count 횟수의 최소만을 저장하는 것이다.
*/

#include <iostream>
#include <algorithm>	// min을 사용하기 위한 헤더
using namespace std;

int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	
	// index 1일 때에는 0이다 왜냐하면 index가 2일 때 1로 가는데 1번이 걸리므로 index 2가 1이기 때문이다.
	int n, count[1000000] = {0, 0};	// n의 범위가 10^6이다.
	
	cin >> n;
	
	for(int i = 2; i <= n; i++){
		count[i] = count[i-1] + 1;	// 일단 1을 빼는 값으로 저장해보고 아래에서 비교 해보는 것이다.
		
		if(i % 2 == 0){
			count[i] = min(count[i], count[i/2] + 1);	// count[i/2] + 1는 count[i/2]에서 2만 큼 곱하는 계산 한번을 더해주는 것이다.
		}
		if(i % 3 == 0){
			count[i] = min(count[i], count[i/3] + 1);	// 위와 같다.
		}
	}
	cout << count[n];
}
