/*
	비트 연산자와 비트 마스킹을 통해 푸는 문제이다.
	
	 ※ 비트 마스킹
	비트는 
	00000000 00000000 00000000 00001111 처럼
	32비트의 경우 첫번째 부호를 나타내는 수를 제외하고 31자리로 나타내는데,
	이를 배열 a[31]처럼 사용해서 입력한 수가 있으면 그 수가 위치하는 자리의 bit를 1로 바꿔주고
	
	ex) 1을 입력하면 00000000 00000000 00000000 00000001
	 ㄴ 3을 입력하면 00000000 00000000 00000000 00000101
	 
	수가 존재하지 않는 것은 0으로 표시하는 방법이 "비트 마스킹이다"
	
	 ※ 비트 연산자
	 
	&	비트단위로 AND 연산을 한다.					>> 0110 & 1010  // 0010	둘다 1이어야 1로 인정된다.
	|	비트단위로 OR 연산을 한다.					>> 0110 | 1010	// 1110 둘중 하나라도 1이면 1로 인정된다.
	^	비트단위로 XOR 연산을 한다.					>> 0110 ^ 1010	// 1100 둘중 하나만 1이어야 1로 인정된다.
	~	단항 연산자로서 피연자의 모든 비트를 반전시킨다.	 >> ~0110		// 1001	1은 0으로 0은 1로 바꾼다.
	<<	피연산자의 비트 열을 왼쪽으로 이동시킨다.		   >> 0110 << 1	  // 1100 << 연산자 뒤에 오는 수만큼 왼쪽으로 비트를 옮긴다. 오른쪽에 비는 비트는 0으로 채운다.
	>>	피연산자의 비트 열을 오른쪽으로 이동시킨다.	  >> 0110 >> 1	 // 0011 >> 연산자 뒤에 오는 수만큼 오른쪽으로 비트를 옮긴다. 왼쪽의 비는 비트는 0으로 채운다.
	
*/
#include <iostream>
#include <string>
using namespace std;

int main(){
	ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);
	
	int n;
	cin >> n;
	
	// 이 문제가 비트마스킹으로 풀리는 이유는 사용자가 입력하는 값이 1 ≤ x ≤ 20 이므로 32비트의 비트 31자리 보다 작으므로 마스킹이 가능하기 때문이다.
	
	/*
		add x: S에 x를 추가한다. (1 ≤ x ≤ 20) S에 x가 이미 있는 경우에는 연산을 무시한다.
		remove x: S에서 x를 제거한다. (1 ≤ x ≤ 20) S에 x가 없는 경우에는 연산을 무시한다.
		check x: S에 x가 있으면 1을, 없으면 0을 출력한다. (1 ≤ x ≤ 20)
		toggle x: S에 x가 있으면 x를 제거하고, 없으면 x를 추가한다. (1 ≤ x ≤ 20)
		all: S를 {1, 2, ..., 20} 으로 바꾼다.
		empty: S를 공집합으로 바꾼다. 
	*/
	
	int S = 0;	// 비트 마스킹의 대상으로 00000000 00000000 00000000 00000000으로 초기화한다.
	int x;
	for(int i = 0; i < n; i++){
		string str;
		cin >> str;
		if(str == "add"){
			cin >> x;
			S |= (1 << x);	// 1은 00000000 00000000 00000000 00000001인데 이를 x만큼 왼쪽으로 옮겨준다. 그리고 | 연산자를 사용하여 이 수가 있든 없든 S에 추가해준다. 이렇게 되면 맨 오른쪽 1은 0이된다.
		}
		else if(str == "remove"){
			cin >> x;
			S &= ~(1 << x);	// x번째 bit가 1인 경우에 지워줘야 하므로 ~를 이용하여 1을 x만큼 옮긴 부분을 0으로 만들고 이를 &를 이용하여 S에서 지워준다.(S의 x번째 bit를 0으로 만들어준다.)
		}
		else if(str == "check"){
			cin >> x;
			if(S & (1 << x)){	// x가 있을 경우
				cout << "1\n";
			}
			else{
				cout << "0\n";
			}
		}
		else if(str == "toggle"){
			cin >> x;
			if(S & (1 << x)){	// X에 x가 있을 경우
				S &= ~(1 << x);	// S에서 x를 지워준다.
			}
			else{
				S |= (1 << x);	// 없는 경우는 S에 x를 추가해준다.
			}
		}
		else if(str == "all"){
			// 이게 조금 이해가 안될 수 있는데, 우리가 20자리 수를 만들고 있으니 21자리만큼 1을 왼쪽으로 옮겨주고, 그 bit를 수로 변환한 것의 1을 빼면 예를들어 10000000가 01111111로 변할태니 모든 수가 채워진다.
			S = (1 << 21) - 1;
		}
		else if(str == "empty"){
			S = 0;	// 00000000 00000000 00000000 00000000 로 초기화해준다.
		}
	}
	
}